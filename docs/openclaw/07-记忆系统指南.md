# 07. 记忆系统完全指南

> 🟡 **难度：进阶** | ⏱️ 阅读时间：25 分钟 | 📋 前置知识：已完成快速开始（[03-快速开始指南](03-快速开始指南.md)）
>
> **本篇你将学会：** 理解 AI 的记忆机制、配置记忆存储、管理和优化 AI 的记忆
>
> **小白速通：** 只看前 2 节（"为什么 AI 需要记忆"、"记忆架构"），了解概念就够了。OpenClaw 的记忆系统开箱即用，不需要额外配置

## 为什么 AI 需要记忆？

你跟朋友聊天，不需要每次都自我介绍。因为朋友记得你是谁、你喜欢什么、上次聊了什么。

但 AI 不一样。大语言模型本质上是"无状态"的 — 每次对话结束，它就把你忘得一干二净。下次你再说"继续上次的方案"，它会一脸茫然地问你"什么方案？"

这就是记忆系统要解决的核心问题：**让 AI 像一个真正的助手一样，记住你是谁、你在做什么、你喜欢什么。**

没有记忆的 AI 助手：

```
你：帮我改一下昨天那个 React 组件
AI：请问你指的是哪个组件？能提供更多上下文吗？
你：……我昨天跟你聊了两个小时啊
AI：抱歉，我没有之前对话的记录。
```

有记忆的 AI 助手：

```
你：帮我改一下昨天那个 React 组件
AI：你说的是 UserProfile 组件吧？昨天你提到想把头像上传功能
    从 base64 改成 presigned URL。我来改一下。
```

差距一目了然。

### 记忆系统的三大价值

| 价值 | 说明 | 举例 |
|------|------|------|
| 连续性 | 跨会话保持上下文 | 记住你正在做的项目、进度、决策 |
| 个性化 | 了解你的偏好和习惯 | 知道你喜欢 TypeScript、不用分号、偏好函数式风格 |
| 效率 | 减少重复沟通 | 不用每次都解释你的技术栈、团队结构、工作流程 |

## OpenClaw 记忆架构

OpenClaw 的记忆系统设计哲学非常务实：**Markdown 文件 + sqlite-vec（轻量级的向量数据库，用于语义搜索） 向量索引，兼顾透明可控和智能检索。**

AI 的记忆源头是写在磁盘上的 Markdown 文件和会话日志。你可以直接用文本编辑器查看、修改、删除 AI 的记忆，完全透明可控。同时，系统使用 sqlite-vec 做向量存储，支持语义搜索、混合搜索（hybrid search）、时间衰减（temporal decay）、最大边际相关性（MMR）和查询扩展（query expansion）等高级检索能力。

### 三层记忆架构

OpenClaw 把记忆分成三层，各司其职：

```
┌─────────────────────────────────────────────────┐
│                  会话记忆 (Session Memory)         │
│  存在于当前对话的上下文窗口中                        │
│  会话结束即消失（除非主动持久化）                     │
│  容量：受模型上下文窗口限制                          │
└──────────────────────┬──────────────────────────┘
                       │ compaction（上下文压缩，当对话太长时自动总结之前的内容） 时自动刷新
                       ▼
┌─────────────────────────────────────────────────┐
│                  短期记忆 (Daily Logs)             │
│  memory/YYYY-MM-DD.md                            │
│  每天一个文件，记录当天的笔记和上下文                 │
│  默认加载今天 + 昨天的日志                          │
│  容量：无限制（每天一个文件）                        │
└──────────────────────┬──────────────────────────┘
                       │ 手动或自动整理
                       ▼
┌─────────────────────────────────────────────────┐
│                  长期记忆 (MEMORY.md)              │
│  精选的持久信息                                    │
│  偏好、决策、重要事实、用户画像                      │
│  每次主会话启动时加载                               │
│  容量：建议控制在 2000 行以内                       │
└─────────────────────────────────────────────────┘
```

### 记忆源

OpenClaw 的记忆来自三类文件：

```
~/.openclaw/workspace/
├── MEMORY.md              # 长期记忆（精选的重要信息）
├── USER.md                # 用户画像（姓名、偏好、习惯）
├── SOUL.md                # Agent 人格定义
├── memory/
│   ├── 2026-02-25.md      # 今天的日志
│   ├── 2026-02-24.md      # 昨天的日志
│   ├── 2026-02-23.md      # 前天的日志
│   └── ...                # 更早的日志
└── sessions/
    └── *.jsonl            # 会话日志（自动记录）
```

记忆源汇总：
- `MEMORY.md` — 手动维护的长期记忆
- `workspace/memory/*.md` — 每日日志
- `sessions/*.jsonl` — 会话历史记录

### 各层记忆详解

#### 会话记忆 (Session Memory)

会话记忆就是当前对话的上下文。你跟 AI 说的每一句话、AI 的每一个回复，都在会话记忆里。

特点：
- 速度最快，AI 可以直接引用
- 容量有限，受模型上下文窗口约束（通常 128K-200K tokens）
- 会话结束就消失
- 对话太长时会触发 compaction（压缩），旧消息会被摘要

```
你：我的项目用 Next.js 14
AI：好的，Next.js 14。（这句话现在在会话记忆里）

... 聊了 200 条消息 ...

AI：（compaction 触发，早期消息被压缩成摘要）
```

#### 短期记忆 (Daily Logs)

每天一个 Markdown 文件，记录当天的重要信息。

```markdown
<!-- memory/2026-02-25.md -->
# 2026-02-25

## 上午
- 讨论了新的认证方案，决定用 NextAuth.js v5
- 用户提到下周三有产品评审会

## 下午
- 修复了 UserProfile 组件的头像上传 bug
- 用户要求把所有 API 响应格式统一为 { data, error } 结构
```

加载策略：
- 每次新会话启动时，自动加载今天和昨天的日志
- 可以通过配置调整加载天数

#### 长期记忆 (MEMORY.md)

精选的、持久的重要信息。这是 AI 的"核心记忆"。

```markdown
<!-- MEMORY.md -->
# 长期记忆

## 用户偏好
- 编程语言：TypeScript，不用分号
- 框架：Next.js 14 + React 18
- 代码风格：函数式优先，避免 class
- 编辑器：VS Code + Vim 键位

## 项目信息
- 当前项目：电商平台重构
- 部署环境：Vercel (前端) + Railway (后端)
- 数据库：PostgreSQL + Prisma ORM

## 重要决策
- 2026-02-20：决定从 REST 迁移到 tRPC
- 2026-02-22：选择 Stripe 作为支付方案
```

## 记忆存储与检索

OpenClaw 的记忆系统使用 sqlite-vec 作为向量存储后端，结合 Markdown 文件实现透明可控的记忆管理。

### 向量存储：sqlite-vec

> ⏭️ **小白可跳过** — 这部分是技术深入分析，记忆系统默认配置已经够用

sqlite-vec 是 OpenClaw 的默认（也是主要的）向量存储方案。它基于 SQLite 扩展，零配置、单文件，同时支持向量语义搜索。

```jsonc
// ~/.openclaw/openclaw.json
{
  "memory": {
    "vectorStore": {
      "provider": "sqlite-vec",
      "path": "~/.openclaw/data/memory.db"
    }
  }
}
```

优点：
- 零配置，开箱即用
- 单文件数据库，不需要安装额外服务
- 支持向量语义搜索
- 记忆源文件（Markdown）仍然可以直接用编辑器查看和修改

### Embedding 提供商

> ⏭️ **小白可跳过** — 这部分是技术深入分析，记忆系统默认配置已经够用

sqlite-vec 需要配合 embedding（把文本转换成数字向量的技术，让 AI 能理解语义相似性） 模型将文本转为向量。OpenClaw 支持多种 embedding 提供商：

| 提供商 | 说明 |
|--------|------|
| OpenAI | `text-embedding-3-small` 等 |
| Gemini | Google 的 embedding 模型 |
| Mistral | Mistral 的 embedding 模型 |
| Voyage | Voyage AI 的 embedding 模型 |

```jsonc
// ~/.openclaw/openclaw.json
{
  "memory": {
    "embedding": {
      "provider": "openai",
      "model": "text-embedding-3-small"
    }
  }
}
```

### 高级检索能力

> ⏭️ **小白可跳过** — 这部分是技术深入分析，记忆系统默认配置已经够用

OpenClaw 的记忆检索不是简单的关键词匹配，而是一套完整的智能检索系统：

| 能力 | 说明 |
|------|------|
| Hybrid Search（混合搜索） | 同时使用关键词匹配和向量语义搜索，综合排序 |
| Temporal Decay（时间衰减） | 越新的记忆权重越高，旧记忆逐渐淡化 |
| MMR（最大边际相关性） | 搜索结果去重，避免返回高度相似的内容 |
| Query Expansion（查询扩展） | 自动扩展搜索词，提高召回率 |

这些能力开箱即用，不需要额外配置。

## 记忆配置详解

记忆系统的行为可以通过 `~/.openclaw/openclaw.json`（JSON5 格式）精细控制。

### 基础配置

```jsonc
// ~/.openclaw/openclaw.json
{
  "agents": {
    "defaults": {
      "memory": {
        "enabled": true,
        "basePath": "~/.openclaw/workspace/memory",
        "loadDays": 2,
        "maxMemoryFileSize": 50000,
        "autoSave": true
      }
    }
  }
}
```

各字段说明：

| 字段 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `enabled` | boolean | `true` | 是否启用记忆系统 |
| `basePath` | string | `"memory"` | 记忆文件存储路径（相对于 workspace） |
| `loadDays` | number | `2` | 启动时加载最近几天的日志 |
| `maxMemoryFileSize` | number | `50000` | 单个记忆文件最大字符数 |
| `autoSave` | boolean | `true` | 是否在 compaction 时自动保存记忆 |

### Compaction 与记忆刷新

这是 OpenClaw 记忆系统最聪明的设计之一。当对话越来越长，上下文窗口快要满的时候，OpenClaw 会触发 compaction（压缩）。在压缩之前，它会自动提醒 AI 把重要信息存到记忆文件里。

```jsonc
// ~/.openclaw/openclaw.json
{
  "compaction": {
    "enabled": true,
    "reserveTokensFloor": 20000,
    "memoryFlush": {
      "enabled": true,
      "softThresholdTokens": 4000,
      "systemPrompt": "Session nearing compaction. Store durable memories now.",
      "prompt": "Write any lasting notes to memory/YYYY-MM-DD.md; reply with NO_REPLY if nothing to store."
    }
  }
}
```

工作流程：上下文使用率达到阈值 → 触发 memoryFlush（隐藏的 Agent 轮次）→ AI 自动把重要信息写入日志 → 执行 compaction 压缩旧消息 → 对话继续。

你也可以在对话中手动触发压缩，使用聊天命令 `/compact`。

| 字段 | 说明 |
|------|------|
| `reserveTokensFloor` | 压缩后至少保留多少 tokens 的上下文 |
| `softThresholdTokens` | 距离压缩还有多少 tokens 时触发记忆刷新 |

### 记忆加载配置

控制每次会话启动时加载哪些记忆：

```jsonc
// ~/.openclaw/openclaw.json
{
  "memory": {
    "loadOnStart": {
      "longTermMemory": true,
      "userProfile": true,
      "dailyLogs": { "enabled": true, "days": 2, "maxTokens": 8000 }
    }
  }
}
```

为什么要限制 `maxTokens`？因为记忆也占上下文窗口。日志写得太详细时，加载太多天会挤占正常对话的空间。

### 按 Agent 配置记忆

不同的 Agent 可以有不同的记忆配置。比如 `main` Agent 加载 3 天日志，`coding` Agent 只加载 1 天，`social` Agent 完全关闭记忆：

```jsonc
// ~/.openclaw/openclaw.json
{
  "agents": {
    "main":   { "memory": { "loadDays": 3, "autoSave": true } },
    "coding": { "memory": { "loadDays": 1, "autoSave": true } },
    "social": { "memory": { "enabled": false } }
  }
}
```

## 对话上下文管理

上下文窗口是 AI 的"工作记忆"，理解它的工作方式对用好记忆系统至关重要。

### 什么是上下文窗口？

上下文窗口就是模型一次能"看到"的所有文本。包括：

```
┌─────────────────────────────────────────┐
│ 系统提示词 (System Prompt)               │  ← 固定占用
│ - Agent 人格 (SOUL.md)                  │
│ - 技能指令                               │
│ - 工具定义                               │
├─────────────────────────────────────────┤
│ 记忆注入                                 │  ← 启动时加载
│ - MEMORY.md                             │
│ - USER.md                               │
│ - 最近几天的日志                          │
├─────────────────────────────────────────┤
│ 对话历史                                 │  ← 动态增长
│ - 用户消息                               │
│ - AI 回复                               │
│ - 工具调用结果                            │
├─────────────────────────────────────────┤
│ 剩余空间                                 │  ← 给 AI 生成回复用
└─────────────────────────────────────────┘
```

常见模型的上下文窗口：Claude 3.5 Sonnet 200K tokens、GPT-4o 128K tokens、Gemini 2.0 1M tokens。

### 滑动窗口策略

当对话越来越长，上下文窗口快满了怎么办？OpenClaw 使用滑动窗口策略：

```
正常对话：  [系统提示 | 记忆 | 消息1 | 消息2 | ... | 消息N]
接近上限：  [系统提示 | 记忆 | [摘要:消息1-50] | 消息51 | ... | 消息N]
继续对话：  [系统提示 | 记忆 | [摘要:消息1-50] | 消息51 | ... | 消息N+M]
```

compaction 的过程：检测到上下文使用率超过阈值 → 触发 memoryFlush，AI 保存重要信息到记忆文件 → 将早期消息压缩成摘要 → 释放上下文空间，继续对话。

### 上下文预算管理

你可以配置各部分占用上下文的比例：

```jsonc
// ~/.openclaw/openclaw.json
{
  "agents": {
    "defaults": {
      "contextBudget": {
        "systemPrompt": 0.15,
        "memory": 0.10,
        "conversation": 0.65,
        "generation": 0.10
      }
    }
  }
}
```

如果记忆文件超过了分配的预算（这里是 10%），OpenClaw 会自动截断，只加载最重要的部分。

## 用户画像和偏好记忆

OpenClaw 有一个专门的文件 `USER.md` 来存储用户画像。这跟 `MEMORY.md` 不同 — `MEMORY.md` 存的是各种杂项记忆，`USER.md` 专门描述"你是谁"。

### USER.md 结构

```markdown
<!-- ~/.openclaw/workspace/USER.md -->
# 用户画像

## 基本信息
- 姓名：老金 | 时区：Asia/Shanghai | 语言：中文为主

## 技术偏好
- 主力语言：TypeScript（不用分号，单引号，2 空格缩进）
- 前端：React + Next.js | 后端：Node.js + Fastify
- 数据库：PostgreSQL | 部署：Docker + Railway

## 沟通偏好
- 喜欢简洁直接的回答，代码示例比文字解释更有用
- 遇到问题先给方案，再解释原因

## 日程习惯
- 工作时间：9:00-18:00
- 每周一 10:00 团队周会 | 每周五 15:00 代码评审
```

### 自动学习用户偏好

开启 `autoLearn` 后，AI 会在对话中自动捕捉你的偏好并更新 `USER.md`：

```jsonc
// ~/.openclaw/openclaw.json
{
  "memory": {
    "userProfile": {
      "autoLearn": true,
      "categories": ["technical_preferences", "communication_style", "work_schedule"],
      "updateFrequency": "daily"
    }
  }
}
```

比如你说"把这个改成箭头函数，我不喜欢 function 关键字"，AI 会自动在 `USER.md` 中记录"偏好箭头函数"。

### 主动让 AI 记住

直接告诉 AI 你想让它记住什么：

```
记住：我的 GitHub 用户名是 laojin-dev
记住：项目部署在 Hetzner 的 VPS 上
记住：我不喜欢在代码里用分号
记住：跟我说话不用太客气，直接说重点
```

AI 会根据内容类型，自动决定写入 `MEMORY.md` 还是 `USER.md`：
- 个人偏好、习惯 → `USER.md`
- 项目信息、决策、事实 → `MEMORY.md`
- 临时笔记、当天事项 → `memory/YYYY-MM-DD.md`

## 记忆工具

AI 有专门的工具来操作记忆：

### memory_search — 语义搜索

从所有记忆文件中搜索相关内容。

```
用户：我之前说过用什么支付方案来着？
AI：（调用 memory_search("支付方案")）
    → 找到 MEMORY.md 中的记录：2026-02-22 决定用 Stripe
AI：你在 2 月 22 号决定用 Stripe 作为支付方案。
```

搜索范围：
- `MEMORY.md` — 长期记忆
- `USER.md` — 用户画像
- `memory/*.md` — 所有日志文件

### memory_get — 精确读取

读取某个记忆文件的特定内容。

```
用户：看看我昨天的笔记
AI：（调用 memory_get("memory/2026-02-24.md")）
    → 返回昨天日志的完整内容
```

### 记忆写入

AI 通过标准的文件写入工具来更新记忆文件。没有专门的"记忆写入"工具 — 这是故意的设计，保持简单。

```
用户：记住，我们决定用 Stripe
AI：（调用 file_write，写入 MEMORY.md）
    好的，已记录到长期记忆中。
```

## 知识库集成 (RAG)

当你需要 AI 记住大量结构化知识（比如公司文档、产品手册、代码库），普通的记忆文件就不够用了。这时候需要 RAG（Retrieval-Augmented Generation，检索增强生成）。

### 什么是 RAG？

简单说：AI 回答问题之前，先从知识库里搜索相关内容，然后带着这些内容去回答。

```
传统方式：
用户提问 → AI 凭记忆回答（可能瞎编）

RAG 方式：
用户提问 → 搜索知识库 → 找到相关文档 → AI 基于文档回答（有据可查）
```

### OpenClaw 的 RAG 实现

OpenClaw 通过 `knowledge` 插件支持 RAG：

```jsonc
// ~/.openclaw/openclaw.json
{
  "plugins": {
    "slots": {
      "knowledge": "knowledge-core"
    }
  },
  "knowledge": {
    "enabled": true,
    "sources": [
      {
        "name": "company-docs",
        "type": "directory",
        "path": "~/Documents/company-wiki",
        "glob": "**/*.md",
        "watch": true
      },
      {
        "name": "project-readme",
        "type": "file",
        "path": "~/projects/myapp/README.md"
      }
    ],
    "embedding": {
      "provider": "openai",
      "model": "text-embedding-3-small"
    },
    "vectorStore": {
      "provider": "sqlite-vec",
      "path": "~/.openclaw/data/knowledge.db"
    }
  }
}
```

### 知识源类型

| 类型 | 说明 | 配置 |
|------|------|------|
| `directory` | 监控整个目录 | `path` + `glob` 模式 |
| `file` | 单个文件 | `path` |
| `url` | 网页内容 | `url` + 刷新频率 |
| `github` | GitHub 仓库 | `repo` + `branch` |

### 向量数据库选择

OpenClaw 支持多种向量数据库作为知识存储：

| 向量数据库 | 特点 | 配置 provider |
|-----------|------|--------------|
| sqlite-vec | 零配置，默认方案 | `"sqlite-vec"` |
| Chroma | 功能更强，支持过滤 | `"chroma"` |
| pgvector | PostgreSQL 扩展，适合已有 PG 的团队 | `"pgvector"` |

### 知识库与记忆管理命令

记忆索引和知识库都通过 `openclaw memory` 子命令管理：

```bash
# 记忆索引管理
openclaw memory status             # 查看记忆索引状态
openclaw memory index              # 重建记忆索引
openclaw memory search "部署"       # 搜索记忆（支持语义搜索）
```

### 记忆 vs 知识库

| 维度 | 记忆系统 | 知识库 (RAG) |
|------|----------|-------------|
| 内容来源 | 对话中产生 | 预先准备的文档 |
| 更新方式 | AI 自动写入 | 手动索引或监控 |
| 搜索方式 | 混合搜索（关键词 + 语义） | 语义向量搜索 |
| 适合内容 | 偏好、决策、笔记 | 文档、手册、代码 |
| 数据量 | 小（几十个文件） | 大（成百上千个文件） |

## 记忆的增删改查操作

### 通过 CLI 操作

```bash
# 查看记忆索引状态
openclaw memory status

# 重建记忆索引（当记忆文件有变动时）
openclaw memory index

# 搜索记忆（支持语义搜索）
openclaw memory search "React 组件"
```

记忆文件本身是 Markdown，可以直接用编辑器查看和修改：

```bash
code ~/.openclaw/workspace/MEMORY.md                    # VS Code
vim ~/.openclaw/workspace/memory/2026-02-25.md          # Vim
```

修改后运行 `openclaw memory index` 重建索引，下次会话启动时 AI 就能看到更新的内容。

### 通过对话操作

直接跟 AI 说就行：

```
你：记住，我们的 API 基础 URL 是 https://api.example.com/v2    → 写入
你：我之前说过 API 地址是什么？                                  → 查询
你：API 地址改了，新地址是 https://api.example.com/v3            → 更新
你：把关于旧项目的记忆都删掉                                     → 删除
你：帮我整理一下长期记忆，删掉过时的信息                          → 整理
```

AI 会自动调用对应的记忆工具完成操作。

## 记忆隐私和安全

记忆文件里可能包含敏感信息。OpenClaw 提供了多层保护机制。

### 敏感信息过滤

配置自动过滤规则，防止 AI 把敏感信息写入记忆：

```jsonc
// ~/.openclaw/openclaw.json
{
  "memory": {
    "security": {
      "sensitivePatterns": [
        "\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b",
        "\\b(sk-|pk-|api_key|password|secret)[\\w-]+\\b"
      ],
      "action": "redact",
      "redactReplacement": "[REDACTED]"
    }
  }
}
```

当 AI 尝试写入包含邮箱、API Key、密码等模式的内容时，敏感部分会被替换为 `[REDACTED]`。

### 记忆文件加密

对于高安全需求的场景，可以开启 AES-256-GCM 加密：

```jsonc
// ~/.openclaw/openclaw.json
{
  "memory": {
    "encryption": {
      "enabled": true,
      "algorithm": "aes-256-gcm",
      "keySource": "env",
      "keyEnvVar": "OPENCLAW_MEMORY_KEY"
    }
  }
}
```

开启后记忆文件在磁盘上是加密的，只有 OpenClaw 运行时才能读取。密钥通过环境变量 `OPENCLAW_MEMORY_KEY` 提供。

### 不应该存入记忆的内容

无论有没有加密，密码、API Key、JWT Token、身份证号、银行卡号等敏感信息都不应该写入记忆文件。用环境变量或密钥管理器代替。

### 记忆审计日志

开启审计日志，记录所有记忆的读写操作：

```jsonc
// ~/.openclaw/openclaw.json
{
  "memory": {
    "audit": {
      "enabled": true,
      "logPath": "~/.openclaw/logs/memory-audit.log",
      "logReads": false,
      "logWrites": true,
      "logDeletes": true
    }
  }
}
```

日志格式：`时间 操作类型 文件 agent=名称 section=章节 chars=字符数`

## 记忆系统调优

> ⏭️ **小白可跳过** — 这部分是技术深入分析，记忆系统默认配置已经够用

### 记忆文件大小控制

`MEMORY.md` 不应该无限增长。配置自动维护：

```jsonc
// ~/.openclaw/openclaw.json
{
  "memory": {
    "maintenance": {
      "maxMemoryFileLines": 500,
      "maxDailyLogLines": 200,
      "autoArchive": { "enabled": true, "archiveAfterDays": 30, "archivePath": "memory/archive/" },
      "warnThreshold": 0.8
    }
  }
}
```

当 `MEMORY.md` 超过 400 行（500 * 0.8）时，AI 会提醒你整理。超过 30 天的日志自动归档。

### 记忆搜索优化

如果记忆文件很多，搜索会变慢。优化建议：

1. 运行 `openclaw memory index` 确保索引是最新的
2. 限制搜索范围，排除归档文件（`"excludeArchive": true`）
3. 给记忆内容加标签方便精确搜索：`## 项目信息 [tags: project, tech-stack]`

### 记忆加载性能

如果启动时加载记忆太慢，减少 `loadDays` 和 `maxTokens`，并通过 `prioritySections` 指定优先加载的章节：

```jsonc
// ~/.openclaw/openclaw.json
{
  "memory": {
    "loadOnStart": {
      "dailyLogs": { "days": 1, "maxTokens": 4000 },
      "longTermMemory": { "maxTokens": 6000, "prioritySections": ["用户偏好", "项目信息"] }
    }
  }
}
```

如果 `MEMORY.md` 超过 token 预算，只加载 `prioritySections` 指定的章节。

## 多用户记忆隔离

如果多个人共用一个 OpenClaw 实例（比如家庭成员或小团队），记忆必须隔离。

### 通过多 Agent 隔离

最简单的方案：每个用户一个 Agent。

```jsonc
// ~/.openclaw/openclaw.json
{
  "agents": {
    "alice": {
      "workspace": "~/.openclaw/workspace-alice",
      "memory": {
        "basePath": "memory"
      }
    },
    "bob": {
      "workspace": "~/.openclaw/workspace-bob",
      "memory": {
        "basePath": "memory"
      }
    }
  }
}
```

每个 Agent 有独立的 workspace，记忆文件完全隔离：

```
~/.openclaw/
├── workspace-alice/
│   ├── MEMORY.md          # Alice 的长期记忆
│   ├── USER.md            # Alice 的用户画像
│   └── memory/            # Alice 的日志
└── workspace-bob/
    ├── MEMORY.md          # Bob 的长期记忆
    ├── USER.md            # Bob 的用户画像
    └── memory/            # Bob 的日志
```

### 通过消息路由绑定

配合多 Agent 路由，让不同联系人的消息自动路由到对应 Agent。在 `channels.bindings` 中配置 `platform`、`contact` 和 `agent` 的映射关系即可。详见 [08. 多 Agent 路由](08-多Agent协作指南.md)。

### 共享记忆方案

如果需要多个 Agent 共享部分记忆，可以用符号链接指向同一个 MEMORY.md 文件，但要注意并发写入可能导致冲突。更安全的做法是通过独立 workspace 隔离，仅在需要时手动同步。

## 记忆插件系统

### 默认插件：memory-core

OpenClaw 默认使用 `memory-core` 插件提供记忆功能。这个插件包含：

- 记忆文件的读写操作
- `memory_search` 和 `memory_get` 工具
- compaction 时的自动记忆刷新
- 日志文件的自动创建和管理

### 关闭记忆功能

如果你不需要记忆（比如一次性的问答场景）：

```jsonc
// ~/.openclaw/openclaw.json
{
  "plugins": {
    "slots": {
      "memory": "none"
    }
  }
}
```

### 多语言记忆（v2026.2.22 新功能）

v2026.2.22 新增多语言记忆支持：

- 西班牙语
- 葡萄牙语
- 日语
- 韩语
- 阿拉伯语

AI 可以用这些语言写入和搜索记忆。搜索时会自动处理多语言匹配。

## 记忆最佳实践

### 1. 定期整理 MEMORY.md

`MEMORY.md` 是 AI 每次启动都会加载的文件。如果它太大太杂，会浪费上下文空间，还可能让 AI 混淆。

建议：
- 每周花 5 分钟整理一次
- 删除过时的信息（比如已完成的项目）
- 合并重复的条目
- 保持分类清晰

### 2. 善用日志文件

日常的临时信息写入日志，不要塞进 `MEMORY.md`：

```
# 好的做法
MEMORY.md → 只放长期有效的信息
memory/2026-02-25.md → 今天的临时笔记

# 不好的做法
MEMORY.md → 什么都往里塞，越来越臃肿
```

### 3. 让 AI 主动记录

重要对话后，主动让 AI 记录：

```
你：把今天讨论的技术方案要点记下来
AI：好的，我把以下要点写入了今天的日志：
    1. 认证方案选择 NextAuth.js v5
    2. 数据库从 MySQL 迁移到 PostgreSQL
    3. 缓存层用 Redis，TTL 设为 1 小时
```

### 4. 分类存储

在 `MEMORY.md` 中用清晰的标题分类：

```markdown
## 技术栈
...

## 项目决策
...

## 团队信息
...

## 工作流程
...
```

### 5. 不要存敏感信息

密码、API Key、Token 等敏感信息不要写入记忆文件。用环境变量或密钥管理器。

### 6. 备份记忆

记忆文件是纯文本，非常适合用 Git 管理或定期导出：

```bash
# Git 管理
cd ~/.openclaw/workspace && git init && git add MEMORY.md USER.md memory/
git commit -m "backup: memory snapshot 2026-02-25"

# 定期打包备份
tar -czf ~/backups/memory-$(date +%Y%m%d).tar.gz ~/.openclaw/workspace/
```

## 常见问题

### Q: AI 怎么突然不记得之前说的话了？

最常见的原因是 compaction。当对话太长，早期消息会被压缩成摘要，细节可能丢失。

解决方案：
- 重要信息主动让 AI 写入记忆文件
- 开启 `memoryFlush`，compaction 前自动保存
- 增大 `reserveTokensFloor`，保留更多上下文

### Q: 记忆文件太大了怎么办？

用 `openclaw memory status` 查看索引状态，直接编辑 `~/.openclaw/workspace/MEMORY.md` 整理内容。超过 30 天的日志可以手动归档到 `memory/archive/` 目录。建议 `MEMORY.md` 控制在 500 行以内。

### Q: 能不能让 AI 忘记某些事？

可以。直接编辑记忆文件删除对应内容，或者告诉 AI：

```
你：忘掉关于旧项目 X 的所有信息
AI：好的，我已从记忆中删除了关于项目 X 的 5 条记录。
```

### Q: 多个 Agent 能共享记忆吗？

默认不共享。每个 Agent 有独立的 workspace 和记忆文件。

如果需要共享，可以用符号链接：

```bash
# 让 coding Agent 共享 main Agent 的 MEMORY.md
ln -s ~/.openclaw/workspace/MEMORY.md ~/.openclaw/workspace-coding/MEMORY.md
```

但要注意并发写入可能导致冲突。更安全的做法是通过独立 workspace 隔离，仅在需要时手动同步。

### Q: 记忆搜索不准确怎么办？

OpenClaw 使用 sqlite-vec 支持混合搜索（关键词 + 语义），搜索质量通常不错。如果仍然不够精确：

1. 运行 `openclaw memory index` 确保索引是最新的
2. 开启 RAG + 知识库插件，扩大搜索范围
3. 给记忆内容加标签，提高匹配精度

### Q: 换了电脑怎么迁移记忆？

记忆就是文件，直接复制或用 Git 同步：

```bash
# 打包导出
tar -czf openclaw-memory.tar.gz ~/.openclaw/workspace/

# 新电脑导入
tar -xzf openclaw-memory.tar.gz -C ~/

# 或者用 Git
cd ~/.openclaw/workspace && git init && git add . && git commit -m "backup"
```

### Q: 记忆系统会影响响应速度吗？

影响很小。主要开销在启动时加载记忆文件（通常 < 1 秒）和 `memory_search` 搜索。如果觉得慢，减少 `loadDays`、限制 `maxTokens`，或运行 `openclaw memory index` 重建索引。

## 下一步

记忆系统搞定了，你的 AI 助手现在能记住你是谁、你在做什么、你喜欢什么。去 [08. 多 Agent 路由](08-多Agent协作指南.md) 学习如何运行多个 AI 助手，让它们各司其职。
